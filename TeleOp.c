#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     br,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     upDownR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     cLift,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     bl,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     fl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     boop,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     upDownL,       tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Motor config

////////////////////////////////Current pchs teleop code 11/4/2013

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "ButtonsDefs.h"  //Buttons definitions

const float MAX_JOYSTICK = 128.0;//used to scale joystick vectors out of 1
bool half_power = false; //If true half motor power
int servoPos = 90;// default servo position = 90 /255
void initializeRobot()//initialize
{
	return;
}

int scaleJoystick(int n){
	if(half_power){
		return (n / MAX_JOYSTICK)	*  50; //scale the joysticks out of 100 rather than 128
	}
	else{
		return (n / MAX_JOYSTICK)	*  100; //scale the joysticks out of 100 rather than 128
	}

}


task main()
{
	initializeRobot();

	waitForStart();   // wait for start of tele-op phase

	while (true)
	{
		getJoystickSettings(joystick);
		////////CUBE LIFT///////////
		if(joystick.joy1_TopHat == pov_north){
			if(half_power){
				motor[cLift] = 50;
			}
			else{
				motor[cLift] = 100;
			}

		}
		else if(joystick.joy1_TopHat == pov_south){
			if(half_power){
				motor[cLift] = -50;
			}
			else{
				motor[cLift] = -100;
			}
		}
		else{
			motor[cLift] = 0;
			motor[upDownR] = 0;
			motor[upDownL] = 0;
			////////////////////
		}
		//rotate left
		if(joystick.joy1_Buttons == button_left_button){
			motor[fr] = 100;
			motor[fl] = -100;
			motor[br] = 100;
			motor[bl] = -100;
		}

		// rotate left

		if(joystick.joy1_Buttons == button_right_button){
			motor[fr] = -100;
			motor[fl] = 100;
			motor[br] = -100;
			motor[bl] = 100;
		}
		//put in a way to limit max motor power -- either 25% or 100%
		if(joystick.joy1_Buttons == button_left_trigger ){
			half_power = true;

		}
		if(joystick.joy1_Buttons == button_right_trigger ){
			half_power = false;

		}

		//end  max motor power scaling

		//Start useless ultrasonic rotator function
		if(joystick.joy1_TopHat == pov_east){
			servoPos = servoPos + 1;
		}
		if(joystick.joy1_TopHat == pov_west){
			servoPos = servoPos - 1;

		}

		motor[upDownL] = joystick.joy1_y2;
		motor[upDownR] = joystick.joy1_y2;

		int y_vals = scaleJoystick(joystick.joy1_y1);
		int x_vals = scaleJoystick(joystick.joy1_x1);

		///////////////Start derp math
		motor[fl] = x_vals + y_vals;
		motor[br] = x_vals + y_vals;

		motor[fr] = y_vals - x_vals;
		motor[bl] = y_vals - x_vals;
		/////////////////End derp math
	}
}
