#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     irF,            sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     lightF,         sensorLightActive)
#pragma config(Sensor, S4,     irR,            sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     fr,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     fl,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     bl,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     br,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     liftA,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     liftB,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     holder,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     flagspinner,   tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
/*#include "hitechnic-sensormux.h"
#include "lego-touch.h"
#include "lego-light.h"
*/
//#define touchBack              msensor_S4_1
//#define lightL             msensor_S4_2
//#define lightR          msensor_S4_3

const int ON_TAPE = 480;
//const int OFF_TAPE = 450;


bool tapeify();

void initializeRobot(){
	bFloatDuringInactiveMotorPWM = false;
	return;
}

void takeDump(){
	motor[holder] = -100;
	wait1Msec(200);
	motor[holder] = 0;
	wait1Msec(600);
	motor[holder] = 100;
	wait1Msec(300);
	motor[holder] = 0;
}

void liftUpAndDownAndTakeDump(){
	motor[liftA] = 100;
	motor[liftB] = 100;
	wait1Msec(700);
	motor[liftA] = 0;
	motor[liftB] = 0;

	takeDump();

	motor[liftA] = -100;
	motor[liftB] = -100;
	wait1Msec(500);
	motor[liftA] = 0;
	motor[liftB] = 0;
}

task updateDisplay(){
	while(true){
		nxtDisplayTextLine(1, "%d" ,SensorRaw[lightF]);
		nxtDisplayTextLine(2, "%d" ,SensorValue[irR]);
		nxtDisplayTextLine(3, "%d" ,SensorValue[irF]);
	}
}

void irify(){
	int bitchTitsVal = 0;
	PlaySound(soundBeepBeep);
	motor[fr] = 0;
	motor[fl] = 0;
	motor[br] = 0;
	motor[bl] = 0;
	wait1Msec(1000);


	ClearTimer(T1);
	while(SensorValue[irF] != 4){
		motor[fr] = -17;
		motor[fl] = 17;
		motor[br] = -17;
		motor[bl] = 17;
	}



	while(SensorValue[irF] != 9 && SensorValue[irR] !=5){
		//	while(time1[T1] < bitchTime){
		motor[fr] = 17;
		motor[fl] = -17;
		motor[br] = 17;
		motor[bl] = -17;
	}

	motor[fr] = 0;
	motor[fl] = 0;
	motor[br] = 0;
	motor[bl] = 0;

	/*bitchTitsVal = SensorValue[bitchTitties];

	while(SensorRaw[lightF]  <= ON_TAPE){
	//	PlaySound(soundBeepBeep);
	motor[fr] = 30;
	motor[fl] = 35;
	motor[br] = 30;
	motor[bl] = 35;
	}

	motor[fr] = 0;
	motor[fl] = 0;
	motor[br] = 0;
	motor[bl] = 0;

	PlaySound(soundBeepBeep);
	PlaySound(soundBeepBeep);
	wait1Msec(1000);

	while(SensorRaw[bitchTitties]  >= bitchTitsVal){
	//	PlaySound(soundBeepBeep);
	motor[fr] = -30;
	motor[fl] = -35;
	motor[br] = -30;
	motor[bl] = -35;
	}
	*/
	while(!(SensorValue[irF] == 9 && SensorValue[irR] == 5)){
		motor[fr] = 17;
		motor[fl] = -17;
		motor[br] = 17;
		motor[bl] = -17;
	}

	motor[fr] = 0;
	motor[fl] = 0;
	motor[br] = 0;
	motor[bl] = 0;

	wait1Msec(400);

	bool probablyOffTape = false;

	while(tapeify()){
	}
	motor[fr] = 25;
	motor[fl] = 25;
	motor[br] = 25;
	motor[bl] = 25;
	wait10msec(50);

	motor[fr] = -25;
	motor[fl] = 25;
	motor[br] = -25;
	motor[bl] = 25;
	wait10msec(150);

	motor[fr] = 25;
	motor[fl] = 25;
	motor[br] = 25;
	motor[bl] = 25;
	wait10msec(200);

	motor[fr] = -25;
	motor[fl] = 25;
	motor[br] = -25;
	motor[bl] = 25;
	wait10msec(150);


	motor[fr] = 25;
	motor[fl] = 25;
	motor[br] = 25;
	motor[bl] = 25;
	wait10msec(300);

}


/*bool tapeify(){
//while(false){
//drive forward until left light loses tape and scan for IR beacon

bool probablyOffTape = false;

if(SensorRaw[lightF]  >= ON_TAPE){
motor[fr] = 8;
motor[fl] = 23;
motor[br] = 8;
motor[bl] = 23;
}
else{
ClearTimer(T1);
int timeCorrection = 0;
while(SensorRaw[lightF]  <= ON_TAPE){
motor[fr] = 20;
motor[fl] = 0;
motor[br] = 20;
motor[bl] = 0;
if(time1[T1] > 300){
timeCorrection = time1[T1];
ClearTimer(T1);
while(time1[T1] < timeCorrection){
motor[fr] = 0;
motor[fl] = 20;
motor[br] = 0;
motor[bl] = 20;
}
ClearTimer(T1);
timeCorrection = 0;
while(SensorRaw[lightF]  <= ON_TAPE){
motor[fr] = 0;
motor[fl] = 20;
motor[br] = 0;
motor[bl] = 20;

if(time1[T1] > 300){
timeCorrection = time1[T1];

ClearTimer(T1);
while(time1[T1] < timeCorrection){
motor[fr] = 20;
motor[fl] = 0;
motor[br] = 20;
motor[bl] = 0;
}
if(SensorRaw[lightF]  <= ON_TAPE){
probablyOffTape = true;
break;
}
}
}
}
}

return !probablyOffTape;
}
}*/

/*bool tapeify(){
//while(false){
//drive forward until left light loses tape and scan for IR beacon

bool probablyOffTape = false;

if(SensorRaw[lightF]  >= ON_TAPE){
motor[fr] = 8;
motor[fl] = 23;
motor[br] = 8;
motor[bl] = 23;
}
else{
ClearTimer(T1);
int timeCorrection = 0;
while(SensorRaw[lightF]  <= ON_TAPE){
motor[fr] = 20;
motor[fl] = 0;
motor[br] = 20;
motor[bl] = 0;
if(time1[T1] > 300){
timeCorrection = time1[T1];
ClearTimer(T1);
while(time1[T1] < timeCorrection){
motor[fr] = 0;
motor[fl] = 20;
motor[br] = 0;
motor[bl] = 20;
}
}
}

return !probablyOffTape;
}
}*/

/*bool tapeify(){
	int i = 0;
	bool stop = false;
	while(!stop && i < 4){
		ClearTimer(T1);
		while(time1[T1] < 300){
			if(i % 2 == 0){
				if(SensorRaw[lightF]  <= ON_TAPE){
					motor[fl] = 25;
					motor[bl] = 25;
					motor[fr] = 0;
					motor[br] = 0;
				}
				else{
					stop = true;
					break;
				}
			}
			else{
				if(SensorRaw[lightF]  <= ON_TAPE){
					motor[fl] = 0;
					motor[bl] = 0;
					motor[fr] = 20;
					motor[br] = 20;
				}
				else{
					stop = true;
					break;
				}
			}
		}
		i = i + 1;
	}
	return !stop;
}
*/
bool tapeify(){
	//while(false){
	//drive forward until left light loses tape and scan for IR beacon

	if(SensorRaw[lightF]  >= ON_TAPE){
		motor[fr] = 13;
		motor[fl] = 28;
		motor[br] = 13;
		motor[bl] = 28;
	}
	else{
		ClearTimer(T1);
		bool probablyOffTape = false;
		int timeCorrection = 0;
		while(SensorRaw[lightF]  <= ON_TAPE){
			motor[fr] = 20;
			motor[fl] = 0;
			motor[br] = 20;
			motor[bl] = 0;
			if(time1[T1] > 300){
				probablyOffTape = true;
				break;
			}
		}
		timeCorrection = time1[T1];
		ClearTimer(T1);
		while(time1[T1] < timeCorrection){
			motor[fr] = 0;
			motor[fl] = 20;
			motor[br] = 0;
			motor[bl] = 20;
		}

		if(probablyOffTape){
			return false;
		}
		else{
			return true;
		}
	}
}

task main()
{
	bool probablyOffTape = false;
	initializeRobot();
	//waitForStart();

	wait1Msec(700);

	motor[motorA] = -50;

	StartTask(updateDisplay);

	while(!tapeify()){
	}

	while(true){
		if(SensorValue[irR] == 5 && SensorValue[irF] == 9){
			irify();
			break;
		}
		else{
			probablyOffTape = tapeify();
		}

		if(probablyOffTape && false){
			break;
		}
	}

	motor[fr] = 0;
	motor[fl] = 0;
	motor[br] = 0;
	motor[bl] = 0;

	while(true){

	}

	//	PlaySound(soundBeepBeep);
}
