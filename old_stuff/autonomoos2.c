#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     frontLight,     sensorLightActive)
#pragma config(Sensor, S3,     backLight,      sensorLightActive)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     fr,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     fl,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     bl,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     br,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     liftA,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     liftB,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     holder,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     flagspinner,   tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-sensormux.h"
#include "hitechnic-irseeker-v2.h"
#include "lego-ultrasound.h"

#define sonicSensor              msensor_S4_1
#define frontRightIR              msensor_S4_3
#define frontLeftIR              msensor_S4_2
#define backRightIR              msensor_S4_4
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.



	int y = 3;
int min;
int max = 200;
float k;
task followline(){
	while(true){
k = (((SensorRaw[frontLight] - min)/(max-min))-0.5)*2*y;

motor[fr] = 10+k;
motor[br] = 10 + k;
motor[bl] = 15 -k;
motor[fl] = 15 - k;
}



}
task UpdateMax(){
	while(true){
if (SensorRaw[frontLight] > max){
max = SensorRaw[frontLight]	
}
}
}
void irturn(){
	
while(HTIRS2readACDir(frontRightIR) > 1){
		motor[fr] = -17;
		motor[fl] = 17;
		motor[br] = -17;
		motor[bl] = 17;
}
}
void takeDump(){
	wait1Msec(300);
	motor[holder] = 100;
	wait1Msec(300);
	motor[holder] = 0;
	wait1Msec(300);
	motor[holder] = -100;
	wait1Msec(300) ;
}

void liftUpAndDownAndTakeDumpAndForward(){
	int sonicpos = USreadDist(sonicSensor);
	while(USreadDist(sonicSensor)!= 0){//not sure what value is need to check
			motor[fr] = 25;
	motor[fl] = 25;
	motor[br] = 25;
	motor[bl] = 25;
	
}
	motor[fr] = 0;
	motor[fl] = 0;
	motor[br] = 0;
	motor[bl] = 0;

	motor[liftA] = 100;
	motor[liftB] = 100;
	wait1Msec(3100);
	motor[liftA] = 0;
	motor[liftB] = 0;

	takeDump();

	motor[liftA] = -100;
	motor[liftB] = -100;
	wait1Msec(2900);
	motor[liftA] = 0;
	motor[liftB] = 0;
	while(USreadDist(sonicSensor)!= sonicpos){
			motor[fr] = -25;
	motor[fl] = -25;
	motor[br] = -25;
	motor[bl] = -25;
	
}
motor[fr] = 0;
	motor[fl] = 0;
	motor[br] = 0;
	motor[bl] = 0;
	
}
void getbackontape(){
	while(HTIRS2readACDir(frontRightIR) != 5 && HTIRS2readACDir(backRightIR) != 9){
		
			motor[fr] = 17;
		motor[fl] = -17;
		motor[br] = 17;
		motor[bl] = -17;
	
	
	}

}

task main()
{


  //waitForStart(); // Wait for the beginning of autonomous phase.
min = SensorRaw[frontLight];
StartTask(UpdateMax);
	while(SensorRaw[frontLight]  <= min + 50){
		motor[fr] = 10;
		motor[fl] = 15;
		motor[br] = 10;
		motor[bl] = 15;
	}
			motor[fr] = 0;
		motor[fl] = 0;
		motor[br] = 0;
		motor[bl] = 0;
		StopTask(UpdateMax);
		
		StartTask(followline);
		while(HTIRS2readACDir(frontRightIR) != 5 && HTIRS2readACDir(backRightIR) != 9){
		}
		StopTask(followline);
		irturn();
		liftUpAndDownAndTakeDumpAndForward();
	getbackontape();
  while (true)
  {}
}
